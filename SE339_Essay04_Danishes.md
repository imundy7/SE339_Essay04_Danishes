# ReactiveUI and ReactiveX
##### _Mason, Caelan, Frank, Isaiah, Vibhu_

---

## Introduction
ReactiveX is a library for creating asynchronous and event-based programs using observable sequences. This approach is similar to how ReactiveUI handles updating the view as the user triggers events. ReactiveUI provides additional features tailored specifically for creating an application with a Model-View-ViewModel (MVVM) pattern. Nevertheless, ReactiveX and ReactiveUI share many similarities and differences between their observables and schedulers. These modules are the driving force behind reactive programming, and ReactiveX and ReactiveUI would not function without them.

## Reactive Programming Patterns
ReactiveUI and ReactiveX both make use of the Observer pattern to handle asynchronous events. Both applications utilize similar functions to manipulate streams of ongoing events. These methods are able to `Create` Observables and define their behavior to "push" data to a stream while also having iterators that "pull" data from the data streams. One key difference is ReactiveUI's inclusion of Model-View-ViewModel elements which increases the portability and maintainability of potential applications. The MVVM pattern works by having observable properties and commands passed between the View and ViewModel such that the ViewModel is constantly communicating with the View which updates automatically. Simultaneously, the Model represents the content of the state as well as other program logic which is retrieved by the ViewModel upon input from the View. This allows a level of abstraction in between the state and the behavior of ReactiveUI which is not present in ReactiveX. One key part of a MVVM framework is the `ICommand` interface which allows the View to trigger logic defined in the ViewModel. ReactiveUI has `ReactiveCommand` which is an implementation of `ICommand`. ReactiveX has no implementation making it ineffective for developing a MVVM pattern.

## Observables

### _ReactiveUI's Observables_
ReaciveUI contains the basic `Observable` but also contains objects and methods to allow for the parts of MVVM architecture to interact with observables. One form of observable in ReactiveUI is the `ReactiveCommand<TInput, TOutput>`. It is created with methods taking parameters of input and output allowing for the definition of commands that may be executed synchronously or asynchronously. It can also be read as an `IObservable<TOutput>` of the output. It further has commands that provide observers for data streams, such as `IsActive()`, which can be used to execute asynchronous commands. `ObservableAsPropertyHelper` is a class that creates a ViewModel property from an `IObservable` object and is useful if you do not plan to mutate the value. The class monitors the data stream for changes and the notifies the scheduler to update the property. It is also useful for exposing the latest value from observables that are derived from other properties. `WhenAny` and `WhenActive` are also observers that monitor observables and notify when a change occurs in the data stream.

### _ReactiveX's Observables_
ReactiveX does not supply many implementations of `IObservable`, instead providing a variety of methods to work with `IObserver`. ReactiveX still has 3 major observable implementations besides the basic `IObservable`. `IGroupedObservable` represents an observable sequence of elements that have a common key. `IQbservable` evaluates queries against a data stream and can also be subscribed too as an observable. There is also `Subject` which stores characteristics like and Observable and can also publish to subscribers like an Observer. There are also three sub implementations of `Subject`. `ReplaySubject` caches all values and can replay them for late subscriptions, `BehaviorSubject` only stores the last value published, and `AsyncSubject` only stores the last value and only publishes when the sequence completes making it similar to `Task`. ReactiveX provides very basic Observables leaving it to the user to implement the chosen functionality.

### _Observables Comparison_
ReactiveUI's `ReactiveCommand`  is an implementation of `ICommand`, an essential part of the MVVM pattern. ReactiveX has no such implementation making it ineffective for developing a MVVM pattern on it's own. This is an example of how ReativeUI takes the base functionality provided by Reactive Extensions and expands upon it to work with MVVM architecture. The `ReactiveCommand` object can take an `IObservable` as input with the `CreateFromObservable()` method, allowing it to accept manipulated data streams from Reactive Extensions commands. By subscribing to `ReactiveComand<TInput, TOutput>` you can use Reactive Extensions to manipulate a data stream and pass it back to the view. ReactiveUI and Reactive Extensions have similar observables but Reactive Extensions provides functionality to combine and manipulate data streams in a way that ReactiveUI does not. ReactiveUI takes the base function of Reactive Extensions and relates them to the MVVM architecture. ReactiveUI benifits heavily from the live data stream manipulation provided by using the  `WhenAny` and `WhenActive` family of functions with Reactive Extensions. 

## Schedulers

### _ReactiveUI's Schedulers_
ReactiveUI provides two app wide schedulers, `RxApp.MainThreadScheduler` and `RxApp.TaskpoolScheduler`, which specify where and/or when to execute tasks related to a corresponding `Observable`. The `RxApp.MainThreadScheduler` scheduler specifically executes tasks on the UI thread mainly for updating the layout of elements of an application. Next, the `RxApp.TaskpoolScheduler` scheduler executes code using the Task Parallel Library (TPL) taskpool. The TPL is part of the .NET framework, and simplifies the process of adding parallelism and concurrency to applications. The TPL accomplishes this by dynamically scaling the degree of concurrency to use all available processors as efficiently as possible. Users of ReactiveUI can use these schedulers along with tasks relating to `Observables` and `ReactiveCommands` to increase their applications performance. 

### _ReactiveX's Schedulers_
ReactiveX has a main app wide scheduler named `AsyncScheduler` that performs the basic scheduler behaviors in which the scheduler queues up `Actions` when received and then asynchronously completes them. `Actions` are similar to tasks in that they are the product of `Observable` except for the fact they can be sent to a scheduler with instructions for executing the task more than once. In that way, if an action needs to be called often at specific time intervals, there is no need to send the same request multiple times thanks to the implementations of `Actions`. Various additional schedulers are derived from the `AsyncScheduler` in order to accommodate different needs during run time. The `AsapScheduler` prioritizes `Actions` marked as `AsapActions` and completes them as fast as possible in comparison to other schedulers. The `AnimationFrameScheduler` completes queued graphical `Actions` called `AnimationFrameActions` before the screen repaints the graphical interface. Finally, the `QueueScheduler` performs `Actions` called `QueueActions` synchronously as scheduled during runtime. 
### _Schedulers Comparison_
Comparatively, ReactiveX's schedulers, such as `AnimationFrameActions` or `AsapScheduler`, are able to handle multiple different types of tasks in different mannerisms. However, ReactiveUI's usage of the TPL protocol instead of `Actions` allows the tasks generalized faster performance for all types of tasks due to the dynamic scaling of concurrency to use all processors as efficiently as possible. Essentially, the schedulers of ReactiveX can perform different sorts of tasks according to needs at runtime whereas ReactiveUI is able to ensure generalized good performance across the board.
## Conclusion

In essence, ReactiveUI and ReactiveX are fairly similar in that they both use an Observer pattern and that they utilize similar functions to manage streams of events, but they do differ in a few areas. A couple of notable differences are that ReactiveUI uses MVVM while ReactiveX does not, and that ReactiveUI's schedulers allow for parallelism while ReactiveX focuses on handling different types of tasks in separate schedulers.

